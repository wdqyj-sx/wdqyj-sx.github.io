<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>eventLoop事件环的理解</title>
    <link href="/2021/10/10/eventLoop%E4%BA%8B%E4%BB%B6%E7%8E%AF%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2021/10/10/eventLoop%E4%BA%8B%E4%BB%B6%E7%8E%AF%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<ul><li>事件环：实现js异步概念，解决异步执行的时候的调度问题</li><li>浏览器由多个进程组成，每个进程包含多个线程</li><li>浏览器运行流程<ul><li>js执行的时候，按照从上到下执行，代码会依次放入执行栈中执行，遇到异步，则    会             把异步回调放入事件队列（消息队列）中，等到执行栈中的代码全部执行完，再依次将事件队列中的函数拿出来依次执行</li><li>代码执行可能会遇到Promise，这些为微任务，微任务执行完浏览器会检测是否要重新渲染（GUI线程）</li><li>执行宏任务时，会把微任务放入微任务队列，每个宏任务都有一个微任务队列，并且宏任务执行完，其微任务队列依次执行并清空</li><li>js引擎、GUI引擎、一般的异步函数（ajax，settimeout、事件）等都可以看做是宏任务</li><li><img src="https://img-blog.csdnimg.cn/50954705b4844e109015ef9e29025de7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6Zeu5Lmf5Y67,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h4 id="试题"><a href="#试题" class="headerlink" title="试题"></a>试题</h4>输出及页面变化</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">&lt;script&gt;<br>       <span class="hljs-built_in">document</span>.body.style.backgroundColor = <span class="hljs-string">&#x27;red&#x27;</span><br>       <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>       <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> &#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>           <span class="hljs-built_in">document</span>.body.style.backgroundColor = <span class="hljs-string">&#x27;yellow&#x27;</span><br>       &#125;)<br>       <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br><br>   &lt;/script&gt;<br></code></pre></div></td></tr></table></figure><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><div class="hljs code-wrapper"><pre><code>* js引擎可以看成一个宏任务，输出1，3* 宏任务执行过程中将Promise存入微任务栈中* 宏任务执行完，执行微任务并清空微任务栈，输出2* 微任务执行完，执行GUI线程* 所以输出 1,3,2，页面打开即为为黄色</code></pre></div><ul><li>输出页面及变化<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.body.style.backgroundColor = <span class="hljs-string">&#x27;red&#x27;</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>          <span class="hljs-built_in">document</span>.body.style.backgroundColor = <span class="hljs-string">&#x27;yellow&#x27;</span><br>      &#125;, <span class="hljs-number">0</span>);<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure></li><li>js引擎相当于宏任务，先执行，输出1,3</li><li>执行过程中遇到settimeout,将其放入宏任务中，</li><li>js引擎执行完，情况其所在的微任务栈，GUI线程调用并会在屏幕刷新的时候是界面发生变化</li><li>宏任务栈中的settimeout发生作用，输出2，并清空其所在的微任务栈，GUi线程调用</li><li>因此输出1,3,2，界面可能是红色闪烁称黄色也可能是直接是黄色（屏幕刷新间隔的原因）<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;p1&#x27;</span>)<br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;s1&#x27;</span>)<br>          &#125;, <span class="hljs-number">0</span>);<br>      &#125;)<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;s2&#x27;</span>)<br>          <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> &#123;<br>              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;p2&#x27;</span>)<br>          &#125;)<br>      &#125;, <span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure></li><li>js引擎执行完一遍之后，将微任务Pormise存入微任务栈，将下面的settimeout存入宏任务栈，执行微任务Promise，所以输出1,遇到宏任务settimeout将其存入宏任务栈</li><li>宏任务栈中执行第一个settimeout，输出s2，遇到微任务Promise，将其存入微任务栈，宏任务执行完，执行其微任务栈，输出p2</li><li>最后执行宏任务settimeout，输出s1</li><li>结果：p1  s2 p2 s1</li></ul>]]></content>
    
    
    <categories>
      
      <category>js基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>async和await的原理及实现</title>
    <link href="/2021/10/10/async%E5%92%8Cawait%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/10/10/async%E5%92%8Cawait%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="async和await的基本使用"><a href="#async和await的基本使用" class="headerlink" title="async和await的基本使用"></a>async和await的基本使用</h4><p><a href="https://editor.csdn.net/md/?articleId=116918202">https://editor.csdn.net/md/?articleId=116918202</a></p><h4 id="generator函数"><a href="#generator函数" class="headerlink" title="generator函数"></a>generator函数</h4><blockquote><p>generator 返回一个遍历器对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">read</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br>&#125;<br><br><span class="hljs-keyword">let</span> it = read()<br><br>it.next()<br>it.next()<br>it.next()<br></code></pre></div></td></tr></table></figure><blockquote><p>generator函数能够分步执行，实际上是利用switch的原理，每一次执行改变switch里面的条件，使之走向不同的分支</p></blockquote><ul><li>利用babel将上述代码转换一下，可以看到：<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><br><span class="hljs-keyword">var</span> _marked = <span class="hljs-comment">/*#__PURE__*/</span>regeneratorRuntime.mark(read);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> regeneratorRuntime.wrap(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read$</span>(<span class="hljs-params">_context</span>) </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">switch</span> (_context.prev = _context.next) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>          _context.next = <span class="hljs-number">3</span>;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>          _context.next = <span class="hljs-number">6</span>;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>          _context.next = <span class="hljs-number">9</span>;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;end&quot;</span>:<br>          <span class="hljs-keyword">return</span> _context.stop();<br>      &#125;<br>    &#125;<br>  &#125;, _marked);<br>&#125;<br><br><span class="hljs-keyword">var</span> it = read();<br>it.next();<br>it.next();<br>it.next();<br></code></pre></div></td></tr></table></figure></li><li>js将read* 函数翻译成了 read$ 函数，里面实质就是一个switch选择语句</li><li>regeneratorRuntime是一个类，里面有一个wrap方法，主要用来处理指针问题，即switch中的选择条件，使每一次next，指针都指向下一个case 语句，并且返回一个遍历器<blockquote><p>我们可以推测出</p></blockquote></li><li>wrap函数传入一个函数参数read$,且这个函数的参数是一个上下文，里面记录了switch应走哪一条语句，并且执行完每一个case后，上下文内容会改变，以便下一次next，再次执行下一条case<blockquote><p>根据思路，我们可以实现这个类</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regeneratorRuntime = &#123;<br>    mark (genFn) &#123;<br>        <span class="hljs-keyword">return</span> genFn<br>    &#125;,<br>    wrap (iteratorFn) &#123;<br>        <span class="hljs-comment">//初始化一个上下文</span><br>        <span class="hljs-keyword">const</span> context = &#123;<br>            <span class="hljs-attr">next</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>,<span class="hljs-comment">//表示是否执行完毕</span><br>            stop () &#123;<br>                <span class="hljs-built_in">this</span>.done = <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">let</span> it = &#123;&#125;<br>        it.next = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>&#123;<br>            <span class="hljs-keyword">let</span> value = iteratorFn(context)<br>            <span class="hljs-keyword">return</span> &#123;<br>                value,<br>                <span class="hljs-attr">done</span>: context.done<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> it<br>    &#125;<br><br><br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>可以看到：</p></blockquote></li><li>每次调用next,会有返回值，返回值是switch语句返回的结果，即yield后面语句返回的结果<blockquote><p>next既然是一个函数，就可以传递参数，我们执行这行代码：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">read</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>, a)<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>, b);<br>    <span class="hljs-keyword">var</span> c = <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>, c)<br><br>&#125;<br><br><span class="hljs-keyword">let</span> it = read();<br>it.next(<span class="hljs-string">&#x27;sx&#x27;</span>);<br>it.next(<span class="hljs-string">&#x27;sx&#x27;</span>);<br>it.next(<span class="hljs-string">&#x27;sx&#x27;</span>);<br></code></pre></div></td></tr></table></figure><blockquote><p>通过babel进行还原源码:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><br><span class="hljs-keyword">var</span> _marked = <span class="hljs-comment">/*#__PURE__*/</span>regeneratorRuntime.mark(read);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a, b, c;<br>  <span class="hljs-keyword">return</span> regeneratorRuntime.wrap(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read$</span>(<span class="hljs-params">_context</span>) </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">switch</span> (_context.prev = _context.next) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>          _context.next = <span class="hljs-number">2</span>;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>          a = _context.sent;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>, a);<br>          _context.next = <span class="hljs-number">6</span>;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>          b = _context.sent;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>, b);<br>          _context.next = <span class="hljs-number">10</span>;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br>          c = _context.sent;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>, c);<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;end&quot;</span>:<br>          <span class="hljs-keyword">return</span> _context.stop();<br>      &#125;<br>    &#125;<br>  &#125;, _marked);<br>&#125;<br><br><span class="hljs-keyword">var</span> it = read();<br>it.next(<span class="hljs-string">&#x27;sx&#x27;</span>);<br>it.next(<span class="hljs-string">&#x27;sx&#x27;</span>);<br>it.next(<span class="hljs-string">&#x27;sx&#x27;</span>);<br></code></pre></div></td></tr></table></figure></li><li>可以看到，next函数可以传递参数，且第一次调用next,参数被赋值给context.sent</li><li>第一次case没有被赋值回a,反而是第二个case才给a赋值</li><li>说明调用后一次next，会获得前一个yield的<blockquote><p>wrap函数相应修改:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regeneratorRuntime = &#123;<br>    mark (genFn) &#123;<br>        <span class="hljs-keyword">return</span> genFn;<br>    &#125;,<br>    wrap (iteratorFn) &#123;<br>        <span class="hljs-comment">// 初始化一个上下文</span><br>        <span class="hljs-keyword">const</span> context = &#123;<br>            <span class="hljs-comment">//初始指针</span><br>            <span class="hljs-attr">next</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>,<span class="hljs-comment">//表示是否执行结束</span><br>            stop () &#123;<br>                <span class="hljs-built_in">this</span>.done = <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>        it = &#123;&#125;<br>        it.next = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>&#123;<br>            context.sent = v<br>            <span class="hljs-keyword">let</span> value = iteratorFn(context);<br>            <span class="hljs-keyword">return</span> &#123;<br>                value,<br>                <span class="hljs-attr">done</span>: context.done<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> it<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><blockquote><p>结果:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">read</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a:&#x27;</span>, a)<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;b:&#x27;</span>, b)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br>&#125;<br><br><span class="hljs-keyword">let</span> it = read()<br><br>it.next(<span class="hljs-string">&#x27;sx1&#x27;</span>) <span class="hljs-comment">//第一次无输出</span><br>it.next(<span class="hljs-string">&#x27;sx2&#x27;</span>) <span class="hljs-comment">//第二次输出 a:sx2</span><br>it.next(<span class="hljs-string">&#x27;sx3&#x27;</span>)<br></code></pre></div></td></tr></table></figure>总结:<blockquote><p>next函数返回一个对象，包括yield语句的执行结果value和context的结束标识done<br>下一个next的参数会被上一个yield的接收值接收</p></blockquote></li></ul><p>利用这个特性，我们可以进行文件的读写：</p><ul><li>创建两个txt：a.txt，b.txt</li><li>a里面存储b的路径</li><li>读取a,获取其值，然后利用这个值，读取b</li><li>实现如下：<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>)<br><span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;util&quot;</span>)<br><span class="hljs-keyword">const</span> readFile = util.promisify(fs.readFile)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">read</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">yield</span> readFile(<span class="hljs-string">&#x27;./source/a.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-keyword">let</span> content = <span class="hljs-keyword">yield</span> readFile(data, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-built_in">console</span>.log(content)<br>&#125;<br><br><span class="hljs-keyword">let</span> it = read();<br><span class="hljs-comment">// 获取第一次读取文件的value </span><br><span class="hljs-keyword">let</span> &#123; value &#125; = it.next();<br><span class="hljs-comment">//这里的value 是一个promise，我们要获取其值传给data</span><br>value.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">value</span>: v &#125; = it.next(data)<br>    <span class="hljs-comment">//v为第二次读取文件的返回值</span><br>    v.then(<span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> &#123;<br>        it.next(d)<br>    &#125;)<br>&#125;)<br></code></pre></div></td></tr></table></figure><blockquote><p>可以看到,read函数中，我们基本将代码变成了同步的形式，只是下面的遍历器的代码，读取文件依然是回调嵌套，这显然不是我们想要的，那么如何将下面的回调嵌套改成同步的形式呢？co库可以解决<br>npm install co</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>)<br><span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;util&quot;</span>)<br><span class="hljs-keyword">const</span> &#123; co &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;co&quot;</span>)<br><span class="hljs-keyword">const</span> readFile = util.promisify(fs.readFile)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">read</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">yield</span> readFile(<span class="hljs-string">&#x27;./source/a.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-keyword">let</span> content = <span class="hljs-keyword">yield</span> readFile(data, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-keyword">return</span> content<br>&#125;<br>co(read()).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(data)<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(err)<br>&#125;)<br></code></pre></div></td></tr></table></figure><blockquote><p>可以看到，co只需要调用一下，传入read函数，就能拿到最后一next得接收值,不用嵌套接收每一次yield的接受值，很方便,代码也基本类似于同步，那么它的原理是什么呢？</p></blockquote></li><li>co返回一个promise，里面存储了最后一次yield的返回值</li><li>yield是逐步执行的，上一个Yield的接收值变成下一个yield的参数<br>我们可以简单模拟一个co库:<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">co</span> (<span class="hljs-params">it</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span> (<span class="hljs-params">data</span>) </span>&#123;<br>            <span class="hljs-keyword">let</span> &#123; value, done &#125; = it.next(data);<br>            <span class="hljs-comment">//如果执行结束，将结果存储</span><br>            <span class="hljs-keyword">if</span> (done) &#123;<br>                resolve(value)<br>            &#125;<br>            <span class="hljs-comment">// 如果没有，递归调用</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">Promise</span>.resolve(value).then(next, reject)<br>            &#125;<br>        &#125;<br>        next()<br>    &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>可以看到,利用co+generator基本实现了代码的串行运行，而async和await就是运用了这个原理，可以说async和await只是co+generator的语法糖,我们把上述代码的* 换成async，把yield换成await，结果依然可以运行:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">await</span> readFile(<span class="hljs-string">&quot;./source/a.txt&quot;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-keyword">let</span> content = <span class="hljs-keyword">await</span> readFile(data, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-keyword">return</span> content<br>&#125;<br><br><span class="hljs-keyword">let</span> ans = read()<br>ans.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(data)<br>&#125;)<br></code></pre></div></td></tr></table></figure><blockquote><p>上述代码在babel中转换,可以看到其原理基本和generator+co类似</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Promise A+规范的实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>node</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise值的穿透和静态方法的实现</title>
    <link href="/2021/10/10/Promise%E5%80%BC%E7%9A%84%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/10/10/Promise%E5%80%BC%E7%9A%84%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="值得传递"><a href="#值得传递" class="headerlink" title="值得传递"></a>值得传递</h4><blockquote><p>then方法不调用参数，可以一直把参数往后传递</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">&#x27;sx&#x27;</span>)<br>&#125;)<br><br>p.then()<br>    .then()<br>    .then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(value)  <span class="hljs-comment">//sx</span><br>    &#125;, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(reason)<br>    &#125;)<br></code></pre></div></td></tr></table></figure><blockquote><p>实现这个原理很简单，只需要在then方法的定义中做一层判断，如果没有传递参数，则构造一个参数，返回需要的数值给下一个Promise</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v<br>onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123; <span class="hljs-keyword">throw</span> err &#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="resolve和reject的实现"><a href="#resolve和reject的实现" class="headerlink" title="resolve和reject的实现"></a>resolve和reject的实现</h4><blockquote><p>相当于调用Promise中的resolve和reject，可以使用then执行其结果</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(value)) <span class="hljs-comment">//1</span><br></code></pre></div></td></tr></table></figure><p>调用该静态方法，可以令其内部创建一个Promise,改变其状态返回即可</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">static</span> resolve (value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        resolve(value)<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">static</span> reject (reason) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        reject(reason)<br>    &#125;)<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="catch实现"><a href="#catch实现" class="headerlink" title="catch实现"></a>catch实现</h4><blockquote><p>值得穿透可以把错误信息放到最后处理，catch就是运用这个原理</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">static</span> <span class="hljs-keyword">catch</span> (errfn) &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">null</span>, errfn)<br> &#125;<br></code></pre></div></td></tr></table></figure><h4 id="all方法的实现"><a href="#all方法的实现" class="headerlink" title="all方法的实现"></a>all方法的实现</h4><ul><li>调用all，用户传进去一个数组，返回一个Promise</li><li>创建一个Promise,在里面遍历数组的每一项，如果是Promise<ul><li>执行then，成功态将数据存入数组中</li><li>失败则调用reject</li></ul></li><li>如果是普通值则直接加入数组中<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">static</span> all (promises) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> timer = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">let</span> result = []<br>            <span class="hljs-keyword">const</span> processSuccess = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index, data</span>) </span>&#123;<br>                result[index] = data<br>                <span class="hljs-keyword">if</span> (++timer === promises.length) &#123;<br>                    resolve(result)<br>                &#125;<br><br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promises.length; ++i) &#123;<br>                <span class="hljs-keyword">let</span> p = promises[i]<br>                <span class="hljs-comment">//判断是否为promise</span><br>                <span class="hljs-keyword">if</span> (p &amp;&amp; <span class="hljs-keyword">typeof</span> p.then === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>                    p.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                        processSuccess(i, value)<br>                    &#125;, reject)<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    processSuccess(i, p)<br>                &#125;<br>            &#125;<br>        &#125;)<br>    &#125;<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Promise A+规范的实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>node</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise异步调用的实现</title>
    <link href="/2021/10/10/Promise%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/10/10/Promise%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Promise可以实现链式调用，既then之后可以接着使用then方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">&#x27;a&#x27;</span>)<br>&#125;)<br>p.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> value<br>&#125;, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> reason<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value) <span class="hljs-comment">//a</span><br>&#125;)<br><br></code></pre></div></td></tr></table></figure><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul><li>then的方法执行后返回一个Promise对象</li><li>then中onFulfilled或onRejected执行的结果会传入下一个Promise中<ul><li>如果then中onFulfilled或onRejected执行的结果为普通值，则作为下一个promise中的resolve执行</li><li>如果为Promise,则令其then执行，直到为普通值，讲结果传入下一个Promise中的resolve或reject</li><li>如果出错，则 reject<h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4></li></ul></li><li>声明一个函数resolvePromise，专门处理上一个then中的onFulfilled或onRejected返回的的结果是否是Promise</li><li>then方法中新建一个Promise对象并返回<ul><li>将上一个onFulfilled或onRejected的执行放在下一个Promise中的executor中执行，这样方便获取其返回值</li><li>返回的结果可能是新声明的Promise本身，所以也要判断一下<ul><li>同步无法先在executor中获取到声明的Promise对象，所以要改成异步</li></ul></li><li>resolvePromise也可能出错，在外面加上try…catch<ul><li>出错直接走reject<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&quot;PENDING&quot;</span><br><span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">&quot;FULFILLED&quot;</span><br><span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">&quot;REJECTED&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span> (<span class="hljs-params">p, x, resolve, reject</span>) </span>&#123;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">executor</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = PENDING<br>        <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">undefined</span><br>        <span class="hljs-built_in">this</span>.reason = <span class="hljs-literal">undefined</span><br>        <span class="hljs-built_in">this</span>.resolveCallback = []<br>        <span class="hljs-built_in">this</span>.rejectCallback = []<br>        <span class="hljs-keyword">const</span> resolve = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">//只有当状态是PENDING时才能改变状态</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === PENDING) &#123;<br>                <span class="hljs-built_in">this</span>.state = FULFILLED<br>                <span class="hljs-built_in">this</span>.value = value<br>                <span class="hljs-built_in">this</span>.resolveCallback.forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn())<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">const</span> reject = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === PENDING) &#123;<br>                <span class="hljs-built_in">this</span>.state = REJECTED<br>                <span class="hljs-built_in">this</span>.reason = reason<br>                <span class="hljs-built_in">this</span>.rejectCallback.forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn())<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//，默认执行构造器</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            executor(resolve, reject);<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-comment">//如果出错这直接变成错误状态</span><br>            reject(e)<br>        &#125;<br>    &#125;<br>    then (onFulfilled, onRejected) &#123;<br><br>        <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === FULFILLED) &#123;<br>                <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">let</span> x = onFulfilled(<span class="hljs-built_in">this</span>.value)<br>                        resolvePromise(p, x, resolve, reject)<br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> (e) &#123;<br>                        reject(e)<br>                    &#125;<br>                &#125;, <span class="hljs-number">0</span>);<br><br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === REJECTED) &#123;<br>                <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-built_in">this</span>.reason)<br>                        resolvePromise(p, x, resolve, reject)<br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> (e) &#123;<br>                        reject(e)<br>                    &#125;<br>                &#125;, <span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === PENDING) &#123;<br>                <span class="hljs-built_in">this</span>.resolveCallback.push(<span class="hljs-function">() =&gt;</span> &#123;<br>                    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-keyword">let</span> x = onFulfilled(<span class="hljs-built_in">this</span>.value)<br>                            resolvePromise(p, x, resolve, reject)<br>                        &#125;<br>                        <span class="hljs-keyword">catch</span> (e) &#123;<br>                            reject(e)<br>                        &#125;<br>                    &#125;, <span class="hljs-number">0</span>);<br>                &#125;)<br>                <span class="hljs-built_in">this</span>.rejectCallback.push(<span class="hljs-function">() =&gt;</span> &#123;<br>                    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-built_in">this</span>.reason)<br>                            resolvePromise(p, x, resolve, reject)<br>                        &#125;<br>                        <span class="hljs-keyword">catch</span> (e) &#123;<br>                            reject(e)<br>                        &#125;<br>                    &#125;, <span class="hljs-number">0</span>);<br>                &#125;)<br>            &#125;<br>        &#125;)<br><span class="hljs-keyword">return</span> p<br>    &#125;<br><br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">Promise</span><br></code></pre></div></td></tr></table></figure><blockquote><p>resolvePromise的操作逻辑:</p></blockquote></li></ul></li></ul></li><li>判断是否是新创建的Promise对象本身，若是这直接reject</li><li>判断是否为Promise对象若是，执行then方法<ul><li>执行完then之后若value或reason为普通值，执行resolv或reject</li><li>若为promise，则继续递归resolvePromise</li><li>出错直接reject</li></ul></li><li>若为常量，直接resolve<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span> (<span class="hljs-params">p, x, resolve, reject</span>) </span>&#123;<br>    <span class="hljs-comment">//若为其本身</span><br>    <span class="hljs-keyword">if</span> (x === p) &#123;<br>        <span class="hljs-comment">//抛出错误</span><br>        reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;错误&#x27;</span>))<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; x !== <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 如果x是用户定义的Promise,为防止其规范，加上一个防护措施，防止状态二次改变</span><br>        <span class="hljs-keyword">let</span> called = <span class="hljs-literal">false</span><br>        <span class="hljs-comment">// try一下，x即使有then方法也不一定能调用,defineProperty定义可以设置限制</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">let</span> then = x.then;<br>            <span class="hljs-comment">//可以认为是Promise</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 执行then，采用call执行，不宜直接调用,</span><br>                then.call(x, <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>                    <span class="hljs-keyword">if</span> (called) &#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                    called = <span class="hljs-literal">true</span><br>                    <span class="hljs-comment">//递归</span><br>                    resolvePromise(p, value, resolve, reject)<br>                &#125;, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>                    <span class="hljs-keyword">if</span> (called) &#123;<br>                        <span class="hljs-keyword">return</span><br>                    &#125;<br>                    called = <span class="hljs-literal">true</span><br>                    reject(reason)<br>                &#125;)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (called)<br>                    <span class="hljs-keyword">return</span><br>                called = <span class="hljs-literal">true</span><br>                resolve(x)<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (e) &#123;<br>            reject(e)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        resolve(x)<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Promise A+规范的实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>node</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise异步处理</title>
    <link href="/2021/10/10/Promise%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"/>
    <url>/2021/10/10/Promise%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前的Promise实现是在同步状态下进行的，试想一下，如果executor里面执行的是异步，根据js执行的顺序，调用then的时候，Promise对象的状态还是PENDING，以下代码无输出:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-built_in">Promise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./Promise&quot;</span>)<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        resolve(<span class="hljs-string">&#x27;sx&#x27;</span>)<br>    &#125;, <span class="hljs-number">0</span>);<br>&#125;)<br><br>p.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value)<br>&#125;, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(reason)<br>&#125;)<br></code></pre></div></td></tr></table></figure><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><ul><li>利用发布订阅模式</li><li>在Promise设置两个数组，分别存储onfulfilled函数和onrejected函数的操作</li><li>执行then的时候，如果状态为PENDING，则利用这两个数组将对应的操作函数存储</li><li>当状态改变时，分别遍历对应的数组，执行里面的方法<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&quot;PENDING&quot;</span><br><span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">&quot;FULFILLED&quot;</span><br><span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">&quot;REJECTED&quot;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">executor</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = PENDING<br>        <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">undefined</span><br>        <span class="hljs-built_in">this</span>.reason = <span class="hljs-literal">undefined</span><br>        <span class="hljs-built_in">this</span>.resolveCallback = []<br>        <span class="hljs-built_in">this</span>.rejectCallback = []<br>        <span class="hljs-keyword">const</span> resolve = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">//只有当状态是PENDING时才能改变状态</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === PENDING) &#123;<br>                <span class="hljs-built_in">this</span>.state = FULFILLED<br>                <span class="hljs-built_in">this</span>.value = value<br>                <span class="hljs-built_in">this</span>.resolveCallback.forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn())<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">const</span> reject = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === PENDING) &#123;<br>                <span class="hljs-built_in">this</span>.state = REJECTED<br>                <span class="hljs-built_in">this</span>.reason = reason<br>                <span class="hljs-built_in">this</span>.rejectCallback.forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn())<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//，默认执行构造器</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            executor(resolve, reject);<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-comment">//如果出错这直接变成错误状态</span><br>            reject(e)<br>        &#125;<br>    &#125;<br>    then (onFulfilled, onRejected) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === FULFILLED) &#123;<br>            onFulfilled(<span class="hljs-built_in">this</span>.value)<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === REJECTED) &#123;<br>            onRejected(<span class="hljs-built_in">this</span>.reason)<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === PENDING) &#123;<br>            <span class="hljs-built_in">this</span>.resolveCallback.push(<span class="hljs-function">() =&gt;</span> &#123;<br>                onFulfilled(<span class="hljs-built_in">this</span>.value)<br>            &#125;)<br>            <span class="hljs-built_in">this</span>.rejectCallback.push(<span class="hljs-function">() =&gt;</span> &#123;<br>                onRejected(<span class="hljs-built_in">this</span>.reason)<br>            &#125;)<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">Promise</span><br></code></pre></div></td></tr></table></figure></li><li>输出：sx<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-built_in">Promise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./Promise&quot;</span>)<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        resolve(<span class="hljs-string">&#x27;sx&#x27;</span>)<br>    &#125;, <span class="hljs-number">0</span>);<br>&#125;)<br><br>p.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value)<br>&#125;, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(reason)<br>&#125;)<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Promise A+规范的实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>node</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise的基本实现</title>
    <link href="/2021/10/10/Promise%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/10/10/Promise%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Promise的基本用法是：创建一个Promise,传入一个回调函数，该回调有两个参数函数，在回调中执行用户操作，如果成功，调用第一个参数回调，如果失败，调用第二个参数回调。<br>其有一个then方法，调用then方法会传入两个函数参数，分别对应成功状态的输出和失败状态的输出</p></blockquote><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul><li>Promise传入的参数回调函数会自动执行</li><li>Promise本身有一个状态，成功的回调和失败的回调分别会将状态改变</li><li>then通过检测状态，来选择执行哪个方法</li><li>基本实现如下：<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&quot;PENDING&quot;</span><br><span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">&quot;FULFILLED&quot;</span><br><span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">&quot;REJECTED&quot;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">executor</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = PENDING<br>        <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">undefined</span><br>        <span class="hljs-built_in">this</span>.reason = <span class="hljs-literal">undefined</span><br>        <span class="hljs-keyword">const</span> resolve = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">//只有当状态是PENDING时才能改变状态</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === PENDING) &#123;<br>                <span class="hljs-built_in">this</span>.state = FULFILLED<br>                <span class="hljs-built_in">this</span>.value = value<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">const</span> reject = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === PENDING) &#123;<br>                <span class="hljs-built_in">this</span>.state = REJECTED<br>                <span class="hljs-built_in">this</span>.reason = reason<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//，默认执行构造器</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            executor(resolve, reject);<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-comment">//如果出错这直接变成错误状态</span><br>            reject(e)<br>        &#125;<br>    &#125;<br>    then (onFulfilled, onRejected) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === FULFILLED) &#123;<br>            onFulfilled(<span class="hljs-built_in">this</span>.value)<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === REJECTED) &#123;<br>            onRejected(<span class="hljs-built_in">this</span>.reason)<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">Promise</span><br></code></pre></div></td></tr></table></figure></li><li>测试<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-built_in">Promise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./Promise&quot;</span>)<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">&#x27;sx&#x27;</span>)<br>&#125;)<br><br>p.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value)<br>&#125;, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(reason)<br>&#125;)<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Promise A+规范的实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>node</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高阶函数、函数柯里化、发布订阅模式和观察者模式的实现</title>
    <link href="/2021/10/10/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E3%80%81%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E3%80%81%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/10/10/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E3%80%81%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E3%80%81%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p> 要想实现Promise A+规范，必须要扫清一下知识上的盲点，在这里梳理一下高阶函数、函数柯里化、发布订阅模式和观察者模式。</p></blockquote><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>一个函数返回另一个函数</li><li>一个函数的参数可以接受一个函数<blockquote><p>高阶函数可以给函数进行功能扩展</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">core</span> (<span class="hljs-params">...arg</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;core&#x27;</span>, arg)<br>&#125;<br><br><span class="hljs-built_in">Function</span>.prototype.before = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>    <span class="hljs-comment">//剩余运算符，接受不定参数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>        fn();<br>        <span class="hljs-comment">//扩展运算发,将数组分为参数</span><br>        <span class="hljs-built_in">this</span>(...args)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;附加的处理逻辑&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">let</span> newCore = core.before(cb)<br>newCore(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)  <span class="hljs-comment">//core [ &#x27;1&#x27;, &#x27;2&#x27; ]</span><br></code></pre></div></td></tr></table></figure></li></ul><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul><li>执行core之前，封装一个高阶函数，传进去一个回调函数</li><li>这样执行core的时候就可以执行回调，回调里面做自己想要的操作</li></ul><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><p>多个参数的传入转换成n个函数的形式接受、每个函数接受一个参数</p></blockquote><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul><li>写一个判断函数类型的函数</li><li>原函数<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isType</span> (<span class="hljs-params">val, type</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(val) == <span class="hljs-string">`[object <span class="hljs-subst">$&#123;type&#125;</span>]`</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(isType(<span class="hljs-string">&#x27;123&#x27;</span>, <span class="hljs-string">&#x27;Number&#x27;</span>)) <span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(isType(<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;Number&#x27;</span>)) <span class="hljs-comment">//true</span><br></code></pre></div></td></tr></table></figure></li><li>柯里化改进<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isType</span> (<span class="hljs-params">type</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(val) == <span class="hljs-string">`[object <span class="hljs-subst">$&#123;type&#125;</span>]`</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> isString = isType(<span class="hljs-string">&#x27;String&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(isString(<span class="hljs-string">&#x27;123&#x27;</span>))  <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(isString(<span class="hljs-number">123</span>)) <span class="hljs-comment">//false</span><br></code></pre></div></td></tr></table></figure><blockquote><p>可以看到，柯里化之后一个函数被改成多个函数分别接收参数，而之前用户调用isType，每次都要把类型当做参数输入，柯里化之后，用户只需要输入一次类型，就可以多次调用函数、输入要判断的值进行类型判断</p></blockquote></li></ul><h4 id="通用函数柯里化的实现"><a href="#通用函数柯里化的实现" class="headerlink" title="通用函数柯里化的实现"></a>通用函数柯里化的实现</h4><ul><li>实现一个函数，将普通函数转换成柯里化函数</li><li>思路：<ul><li>声明一个函数，其参数为普通函数</li><li>内部创建一个函数，参数初始化为空数组arg，其返回值为一个函数</li><li>如果arg的长度等于普通函数的长度则返回普通函数并执行。</li><li>如果没有达到，则返回一个新函数，参数为newArg,递归调用内部函数，将newArg和arg合并作为新的arg<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">a, b, c, d</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b + c + d<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curring</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> inner = <span class="hljs-function">(<span class="hljs-params">arg = []</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> arg.length &gt;= fn.length ? fn(...arg) : <span class="hljs-function">(<span class="hljs-params">...newArg</span>) =&gt;</span> inner([...arg, ...newArg])<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> inner()<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(curring(sum)(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)) <span class="hljs-comment">//10</span><br></code></pre></div></td></tr></table></figure><h4 id="利用柯里化函数实现类型判断"><a href="#利用柯里化函数实现类型判断" class="headerlink" title="利用柯里化函数实现类型判断"></a>利用柯里化函数实现类型判断</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isType</span> (<span class="hljs-params">type, val</span>) </span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(val) == <span class="hljs-string">`[object <span class="hljs-subst">$&#123;type&#125;</span>]`</span><br>&#125;<br><br><span class="hljs-keyword">let</span> util = &#123;&#125;;<br><br>[<span class="hljs-string">&#x27;String&#x27;</span>, <span class="hljs-string">&#x27;Number&#x27;</span>, <span class="hljs-string">&#x27;Null&#x27;</span>, <span class="hljs-string">&#x27;Boolean&#x27;</span>, <span class="hljs-string">&#x27;Undefined&#x27;</span>].forEach(<span class="hljs-function"><span class="hljs-params">type</span> =&gt;</span> &#123;<br>    util[<span class="hljs-string">&#x27;is&#x27;</span> + type] = curring(isType)(type)<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(util.isString(<span class="hljs-string">&#x27;123&#x27;</span>))  <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(util.isNumber(<span class="hljs-number">123</span>))  <span class="hljs-comment">//true</span><br></code></pre></div></td></tr></table></figure><h2 id="发布订阅者模式"><a href="#发布订阅者模式" class="headerlink" title="发布订阅者模式"></a>发布订阅者模式</h2><h4 id="高阶函数的形式解决并发问题"><a href="#高阶函数的形式解决并发问题" class="headerlink" title="高阶函数的形式解决并发问题"></a>高阶函数的形式解决并发问题</h4><blockquote><p>node主线程中，异步回调是在主线程执行后执行的、因此想要收集异步函数执行的结果的集合，可以采用高阶函数的形式</p></blockquote></li></ul></li><li>高阶函数中设置一个数组存储异步数据，设置一个条件，当条件达成，执行传入的回调</li><li>高阶函数返回一个函数，通过函数的参数接受异步的数据<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">after</span> (<span class="hljs-params">_timer, callback</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> arr = []<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">data, index</span>) =&gt;</span> &#123;<br>        arr[index] = data<br>        <span class="hljs-keyword">if</span> (--_timer == <span class="hljs-number">0</span>) &#123;<br>            callback(arr)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> out = after(<span class="hljs-number">2</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(data) <span class="hljs-comment">// [a,b]</span><br>&#125;)<br><br>fs.readFile(<span class="hljs-string">&quot;./a.txt&quot;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    out(data, <span class="hljs-number">0</span>)<br>&#125;)<br>fs.readFile(<span class="hljs-string">&quot;./b.txt&quot;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    out(data, <span class="hljs-number">1</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><h4 id="发布订阅者模式解决"><a href="#发布订阅者模式解决" class="headerlink" title="发布订阅者模式解决"></a>发布订阅者模式解决</h4></li><li>声明一个类，包含一个数组存储订阅的函数，一个接受订阅的函数，一个发布函数，用来接受数据，并执行订阅函数<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>)<br><br><span class="hljs-keyword">const</span> events = &#123;<br>    <span class="hljs-attr">_arr</span>: [],<br>    <span class="hljs-attr">on</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>        <span class="hljs-built_in">this</span>._arr.push(fn)<br>    &#125;,<br>    <span class="hljs-attr">emit</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>        <span class="hljs-built_in">this</span>._arr.forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> &#123;<br>            fn(data)<br>        &#125;)<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">let</span> arr = []<br><span class="hljs-comment">//订阅</span><br>events.on(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    arr.push(data)<br>    <span class="hljs-keyword">if</span> (arr.length &gt;= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(arr)<br>    &#125;<br>&#125;)<br><br>fs.readFile(<span class="hljs-string">&quot;./a.txt&quot;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//发布</span><br>    events.emit(data)<br>&#125;)<br>fs.readFile(<span class="hljs-string">&quot;./b.txt&quot;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    events.emit(data)  <span class="hljs-comment">//[a,b]</span><br>&#125;)<br></code></pre></div></td></tr></table></figure><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2></li><li>被观察者绑定观察者</li><li>当被观察者状态改变的时候，绑定的观察者会更新状态<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">subJect</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name<br>        <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&#x27;笑&#x27;</span><br>        <span class="hljs-built_in">this</span>.observer = []<br>    &#125;<br>    <span class="hljs-comment">// 关联观察者</span><br>    attach (o) &#123;<br>        <span class="hljs-built_in">this</span>.observer.push(o)<br>    &#125;<br>    <span class="hljs-comment">//状态改变</span><br>    setState (newState) &#123;<br>        <span class="hljs-built_in">this</span>.state = newState<br>        <span class="hljs-comment">//通知观察者</span><br>        <span class="hljs-built_in">this</span>.observer.forEach(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> &#123;<br>            <span class="hljs-comment">//观察者更新状态</span><br>            o.updata(<span class="hljs-built_in">this</span>.name, <span class="hljs-built_in">this</span>.state)<br>        &#125;)<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    updata (name, state) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>的状态变为:<span class="hljs-subst">$&#123;state&#125;</span>`</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//声明被观察者</span><br><span class="hljs-keyword">const</span> baby = <span class="hljs-keyword">new</span> subJect(<span class="hljs-string">&quot;baby&quot;</span>)<br><span class="hljs-comment">//声明观察者</span><br><span class="hljs-keyword">const</span> mother = <span class="hljs-keyword">new</span> Observer()<br><span class="hljs-comment">//绑定观察者</span><br>baby.attach(mother)<br><br>baby.setState(<span class="hljs-string">&#x27;哭&#x27;</span>) <span class="hljs-comment">//baby的状态变为:哭</span><br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Promise A+规范的实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>node</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
